using System;
using UnityEngine;
using UnityEngine.Assertions;

namespace CircularPlatformer
{
    /// <summary>
    /// Base class for tracking where the player is aiming with the
    /// current controller
    /// </summary>
    public abstract class ControllerTracker : ITracker, IDisposable
    {
        /// <summary>
        /// The interface used to compute how ray will collide with the world space
        /// </summary>
        private readonly IWorldCollider _mapCollider;

        /// <summary>
        /// The interface explain how a point on the space world
        /// should be projected onto the original space
        /// </summary>
        private readonly IWorldMapper _worldMapper;

        private bool _disposedValue;

        private readonly TrackerProvider _trackerProvider;

        public ControllerTracker()
        {
            _mapCollider = ServiceLocator.Get<IWorldCollider>();
            _worldMapper = ServiceLocator.Get<IWorldMapper>();
            _trackerProvider = ServiceLocator.Get<TrackerProvider>();

            _trackerProvider.Register(this);

            Assert.IsNotNull(_mapCollider, "There are no MapCollider registered");
            Assert.IsNotNull(_worldMapper, "There are no WorldMapper registered");
        }

        /// <summary>
        /// This provide the target ray generated by the controller
        /// </summary>
        /// <returns></returns>
        protected abstract Ray GetTargetRay();

        public Vector3 GetTrackedPosition()
        {
            var ray = GetTargetRay();
            var mapCollision = _mapCollider.RayCollisionPoint(ray);
            if (mapCollision == null)
            {
                Debug.LogWarning("For some reason the controller ray does not collide with the world");
                return Vector3.zero;
            }

            var trackedPosition = _worldMapper.ConvertPoint(mapCollision.Value);
            return trackedPosition;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects)
                }

                _trackerProvider.Unregister(this);
                _disposedValue = true;
            }
        }

        // // TODO: override finalizer only if 'Dispose(bool disposing)' has code to free unmanaged resources
        // ~ControllerTracker()
        // {
        //     // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        //     Dispose(disposing: false);
        // }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
